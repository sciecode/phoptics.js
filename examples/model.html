<html>

<head>
  <title>Phoptic.js - Geometry Processing</title>
  <style>
    html,
    body {
      margin: 0;
      background-color: rgba(.3, .3, .3, 1);
    }

    canvas {
      width: 100%;
      height: 100vh;
    }
  </style>
  <script type="importmap">
      {
        "imports": {
          "phoptics": "../src/engine/export.mjs",
          "phoptics/math": "../src/datatypes/export.mjs",
          "phoptics/utils/": "../src/utils/"
        }
      }
    </script>
</head>

<body>
  <script type="module">
    import {
      Engine, Mesh, Geometry, Vertex, Index, RenderList, Shader, Material, Texture, CanvasTexture,
      RenderPass, RenderTarget, StructuredBuffer, Format
    } from 'phoptics';
    import { Vec3, Vec4, Quat, Mat3x4, Mat4x4 } from 'phoptics/math';
    import { Orbit } from 'phoptics/utils/modules/controls/orbit.mjs';
    import { OBJLoader } from 'phoptics/utils/loaders/obj_loader.mjs';
    import { ShaderLib } from 'phoptics/utils/modules/shaders/shader_lib.mjs';
    import { builtin } from 'phoptics/utils/modules/shaders/builtin.mjs';
    import { optimize_geometry } from 'phoptics/utils/modules/geometry/optimizer.mjs';
    import { generate_tangents } from 'phoptics/utils/modules/geometry/tangent.mjs';
    import { compress, uncompress } from 'phoptics/utils/modules/geometry/compression.mjs';

    import model_shader from './assets/shaders/objects/model_shader.mjs';
    import model_wireframe_shader from './assets/shaders/objects/model_wireframe_shader.mjs';

    const dpr = window.devicePixelRatio;
    let shader_lib = new ShaderLib(builtin);
    let viewport = { width: window.innerWidth * dpr | 0, height: window.innerHeight * dpr | 0 };
    let engine, canvas_texture, render_pass, render_target, scene, camera, orbit;
    let mesh, obj_pos = new Vec3(), q = new Quat();

    const renderlist = new RenderList();

    (async () => {
      engine = new Engine(await Engine.acquire_device());

      canvas_texture = new CanvasTexture({ format: Engine.canvas_format() });
      canvas_texture.set_size(viewport);
      document.body.append(canvas_texture.canvas);

      camera = new StructuredBuffer([
        { name: "projection", type: Mat4x4 },
        { name: "view", type: Mat3x4 },
        { name: "position", type: Vec4 },
        { name: "luma", type: Vec4 },
      ]);

      render_pass = new RenderPass({
        multisampled: true,
        formats: {
          color: [canvas_texture.format],
          depth: Format.DEPTH32,
        },
        bindings: [{ name: "camera", resource: camera }]
      });

      const multisampled_texture = new Texture({
        renderable: true, multisampled: true,
        size: viewport, format: canvas_texture.format
      });
      const depth_texture = new Texture({
        renderable: true, multisampled: true,
        size: viewport, format: render_pass.formats.depth
      });

      render_target = new RenderTarget({
        color: [{
          view: multisampled_texture.create_view(),
          resolve: canvas_texture.create_view(),
          clear: [.05, .05, .05, 0]
        }],
        depth: { view: depth_texture.create_view(), clear: 0 }
      });

      render_pass.set_render_target(render_target);

      orbit = new Orbit(canvas_texture.canvas);
      orbit.target.set(0, 0, 0);
      orbit.position.set(0, 0, 2);
      orbit.update();
      const exposure = calc_tonemap(1, 250);
      camera.luma.set(exposure.r_nits, exposure.r_nb);
      camera.projection.perspective(Math.PI / 3, viewport.width / viewport.height, .1, 100);

      shader_lib.register({
        model: model_shader,
        wireframe: model_wireframe_shader,
      });

      const material = new Material({
        shader: shader_lib.get('model'),
        dynamic: [{ name: "world", type: Mat3x4 }],
      });

      let geo = await new OBJLoader().load('./assets/models/cerberus.obj');
      optimize_geometry(geo);
      // const compressed = compress(geo);
      // geo = uncompress(compressed);

      // TODO: MikkTspace
      generate_tangents(geo, { position: { id: 0 }, normal: { id: 1 }, uv: { id: 2 } });

      const mesh = new Mesh(geo, material);
      // create wireframe
      const face_count = geo.draw.count / 3;
      const indices = new Uint32Array(geo.draw.count * 2);
      for (let i = 0; i < face_count; i++) {
        const i3 = i * 3, i6 = i * 6;
        indices[i6] = indices[i6 + 5] = geo.index.data[i3];
        indices[i6 + 1] = indices[i6 + 2] = geo.index.data[i3 + 1];
        indices[i6 + 3] = indices[i6 + 4] = geo.index.data[i3 + 2];
      }
      const geo_wireframe = new Geometry({
        draw: { count: geo.draw.count * 2 },
        index: new Index({ data: indices, stride: 4 }),
        vertices: [new Vertex({
          data: geo.attributes.vertices[0].data,
          stride: geo.attributes.vertices[0].stride
        })]
      });
      const material_wireframe = new Material({
        shader: shader_lib.get('wireframe'),
        dynamic: [{ name: "world", type: Mat3x4 }],
        graphics: { primitive: 'line-list' }
      });
      const mesh1 = new Mesh(geo_wireframe, material_wireframe);
      renderlist.add(mesh1);
      renderlist.add(mesh);

      const q = new Quat().rot_y(Math.PI / 2);
      mesh.dynamic.world.rotate(q);
      mesh1.dynamic.world.rotate(q);

      animate();
    })();

    const calc_tonemap = (ev2, nits) => {
      let r_nits = 1 / nits;
      let r_nb = .5 * (2 ** ev2) * r_nits;
      return { r_nits, r_nb };
    };

    const auto_resize = () => {
      const dpr = window.devicePixelRatio;
      const newW = (canvas_texture.canvas.clientWidth * dpr) | 0;
      const newH = (canvas_texture.canvas.clientHeight * dpr) | 0;

      if (viewport.width != newW || viewport.height != newH) {
        viewport.width = newW; viewport.height = newH;
        render_target.set_size(viewport);

        camera.projection.perspective(Math.PI / 3, viewport.width / viewport.height, .1, 100);
      }
    };

    const animate = () => {
      requestAnimationFrame(animate);

      auto_resize();

      const nr = performance.now() / 2000;

      camera.position.copy(orbit.position);
      camera.view.copy(orbit.view);
      camera.update();

      engine.render(render_pass, renderlist);
    }
  </script>
</body>

</html>